<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@500&display=swap" rel="stylesheet">
<style>
@import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@500&display=swap');
</style> 
<style type="text/css">

body{
	font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
	font-weight: 300;
	margin: 40px; 	
}

h1, h2, h3, h4{
	font-family: 'Open Sans', serif;
}

h1{
	font-size:2.2em;
}

div > h1{
	padding:0;	
}

h2{
	font-size:1.8em;
	font-weight:400;	
}

h3{
font-size:1.6em;
font-weight:400;	
}

h4{
font-size:1.5em;
font-weight:400;	
}

p, a{
font-family: Arial, Helvetica, sans-serif;
font-size:1.0em;
}
</style>
<title>XSLT within the browser in 2023: Drag and Drop API - Part 2</title>
</head>
<body>
<h1>XSLT within the browser in 2023: XPath in Javascript - Part 3</h1>

<h2>Recap</h2>

<p>In this Part we will look at using XPath in Javascript</p>

<h4>XPath</h4>

<p>XPath provides a path-based syntax used to select the contents of XML documents. It can select individual or groups of elements (node sets), text content and attribute content. It can also be used to count number of elements or attributes.</p>

<p>Within web browsers, assume only XPath version 1.0 is available. Outside of web browsers, XPath versions up to 3.1 are available. XPath versions beyond 1.0, maintain a relation with XQuery.</p>

<p>The official specification can be found here: <a href="https://www.w3.org/TR/1999/REC-xpath-19991116/" title="XML Path Language (XPath)">XML Path Language (XPath) Version 1.0</a></p>

<h4>Useful XPath</h4>
<p>There are many resources on XPath, in essence these are the most useful patterns to know. As the Perseus' Digital Library Herodotus document is a TEI document these examples you might encounter when trying to use XPath to navigate around a TEI document. </p>

<table>
<tr>
<td>.</td>
<td>The context node - this can be used to assign an XPath relative to the current location. </td>
</tr>
<tr>
<td>/</td>
<td>The root node - can be the starting point if XPath is required to match from the root node</td>
</tr>
<tr>
<td>//</td>
<td>- matches self or descendents - this is often used if you want to match all elements with a particular name e.g. this XPath count(//name) returns counts all name elements in the document.</td>
</tr>
<tr>
<td>section/*/note</td>
<td>Matches notes that are descendants of section, with an unspecified element between section and note. I.e this selects notes that are grandchildren of section.</td>
</tr>
<tr>
<td>//category/catDesc</td>
<td>If you know the document and know you want the first item you can use this format. Here the match is made on all catDesc elements that are childen of category elements. </td>
</tr>
<tr>
<td>//category/catDesc[.="Drama"]</td>
<td>Here is an example using the current node to match those catDesc elements which have the text content "Drama" and who are children of a category element</td>
</tr>
<tr>
<td>//category[catDesc="Drama"]</td>
<td>Here is an example using the current node to match those category elements which have a catDesc child with the text content "Drama". Compare this with the above example - this path matches category element, whereas the above example matches the catDesc elements.</td>
</tr>
<tr>
<td>//milestone[@unit]</td>
<td>Matches milestone that have a unit attribute.</td>
</tr>
<tr>
<td>//milestone[@unit="chapter"]</td>
<td>Matches milestone that have a unit attribute equal to "chapter" - i.e match all chapters.</td>
</tr>
<tr>
<td>div1 | milestone</td>
<td>Matches div1 or milestone elements</td>
</tr>
<tr>
<td>count(//milestone[@unit="chapter"])</td>
<td>counts the number of milestone elements that have a unit attribute with the value "chapter" i.e counts all the chapters.</td>
</tr>
<tr>
<td>//div1[@type="Book" and @n=1]//name[@type="pers"]</td>
<td>Matches name elements with attribute type of "pers" that are descendents of div1 element with type attribute of "Book" and n attribute of "1" (i.e Book 1) - i.e match all named persons in Book 1.</td>
</tr>
<tr>
<td>//div1[@type="Book" and @n=1]//milestone[@unit="chapter" and @n="1"]</td>
<td>Matches milestone elements with attribute unit of "chapter" and arribute n of "1" that are descendents of div1 element with type attribute of "Book" and n attribute of "1" (i.e Book 1) - i.e match chapter 1 within book 1</td>
</tr>
<tr>
<td>//div1[@type="Book" and @n=1]//milestone[@unit="chapter"][position() = last()]</td>
<td>Matches the last chapter from book 1.</td>
</tr>
<tr>
<td>element[not(@id)]</td>
<td>Matches elements that don't have an id attribute</td>
</tr>
</table>
</br>

<h4>XPath in Javascript</h4>

<p>XPath can be used in Javascript through using <code>document.evaluate</code>. We can use <code>evaluate</code> on the HTML document itself or on a loaded XML document. We have already seen examples of how to load the XML file using Javascript.</p>

<p>In this case I am using the JQuery <code>get()</code> method we have used previously to load the XML document, then using <code>evaluate</code> to apply a XPath expression to the XML document. The convention appears to be that a try-catch block is used with a iterator method <code>iterateNext</code>. 

<pre>
<code>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;XPath&lt;/title&gt;
&lt;script type="text/javascript" src="jquery-3.6.0.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Herodotus&lt;/h2&gt;

&lt;div id="example"&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;

(function(){

if (!('XPathEvaluator' in window)) {
	console.log('XPath does not appear to be available in this browser. Please try another.');
	return;
}else{
	console.log('XPath available.');
}


$.get("data/Perseus_text_1999.01.0126.xml", function(doc) {

	let xpath = doc.evaluate('//div1[@type="Book" and @n=1]//milestone[@unit="chapter" and @n="1"]', doc, null, XPathResult.ANY_TYPE, null);
	let output = [];
	let count = 0;  

	try {
	  let node = xpath.iterateNext();
	  while (node) {
	    count++;
            output.push("&lt;h3&gt;Chapter" + count + "&lt;h3&gt;" + node.textContent + "&lt;br/&gt;");
	    node = xpath.iterateNext();
	  }
	}
	catch (e) {
	  alert( 'Error: Document tree modified during iteration ' + e );
	}

	$("#example").append(names.join(" "));
});

})();

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code>
</pre>

<p>You can see from this example that the syntax of XPath lends itself to passing variables to pull out specific elements.</p>

<pre>
<code>
	 
//assuming values obtained from sanitised HTML inputs or variables and that the values do not exceed the number of book or chapters within the XML document
	
let bookNumber = 1;
let chapterNumber = 1;

let xpath = doc.evaluate('//div1[@type="Book" and @n="' + bookNumber + '"]//milestone[@unit="chapter" and @n="' + chapterNumber + '"]', doc, null, XPathResult.ANY_TYPE, null);

</code>
</pre>

<p>A fully worked up example can be left as an exercise for the reader :)</p>

<h4>XPath in PHP</h4>

<p>To use use XPath in PHP, use either the <code>query()</code> or <code>evaluate()</code> methods of <a href="https://www.php.net/manual/en/class.domxpath.php" title="PHP.net | DOMXPATH">DOMXPath</a>, a class of the PHP XML DOM or use <a href="https://www.php.net/manual/en/simplexmlelement.xpath" title="PHP.net | PHP:SimpleXMLElement::xpath">SimpleXMLElement::xpath</a> which is a SimpleXML method to match XPath expressions.</p>


<h3>DOMXPath</h3>
<p>DOMXPath supports XPath 1.0</p>


<h4>Example 12</h4>
<p>This example uses the DOMXPath <code>query()</code> method which should be used when a DOM NodeList is the expected return type when the XPath expression is applied. Note the various <code>libxml</code> functions which will help pick up errors in the XPath expression. </p>
<pre>
<code>
&lt;?php

$xml = "data/Perseus_text_1999.01.0126.xml";
$xmldoc = new DOMDocument();

if (file_exists($xml)){

	if(!$xmldoc-&gt;load($xml)){
	    	echo "could not load xml documents";
	} 

	libxml_use_internal_errors(true);

	$xpath = new DOMXPath($xmldoc);
	$nodes = $xpath-&gt;query('//milestone[@unit="chapter"]');
	if(!$nodes){
		 foreach (libxml_get_errors() as $error) {
		    echo "Libxml error: {$error-&gt;message}\n";
	    	 }
	}else{
		foreach($nodes as $node){
		    echo $node-&gt;tagName;
		}
	}

	libxml_use_internal_errors(false);
}

?&gt;
</code>
</pre>

<h4>Example 13</h4>
<p>This example uses the DOMXPath <code>evaluate()</code> method which should be used when a typed return from the XPath is expected to be returned - i.e a number or text string is expected rather than a DOM NodeList.</p>
<pre>
<code>
&lt;?php

$xml = "data/Perseus_text_1999.01.0126.xml";
$xmldoc = new DOMDocument();

if (file_exists($xml)){

	if(!$xmldoc-&gt;load($xml)){
	    	echo "could not load xml documents";
	} 

	libxml_use_internal_errors(true);

	$xpath = new DOMXPath($xmldoc);

	$count = $xpath-&gt;evaluate('count(//milestone[@unit="chapter"])');
	if(!$count){
		 foreach (libxml_get_errors() as $error) {
		    echo "Libxml error: {$error-&gt;message}\n";
	    	 }
	}else{
		echo "There are {$count} chapters";
	}

	libxml_use_internal_errors(false);
}

?&gt;
</code>
</pre>


<h3>SimpleXML</h3>

<p>SimpleXML provides another method to traverse XML documents. It includes a simple way to apply XPath expressions.</p>

<h4>Example 14</h4>
<pre>
<code>
&lt;?php

$xml = "data/Perseus_text_1999.01.0126.xml";

if (file_exists($xml)){
	
	$xmldoc = simplexml_load_file($xml);

	libxml_use_internal_errors(true);
    
	$result = $xmldoc->xpath('//milestone[@unit="chapter"]');
	
	if(!$result){
		 foreach (libxml_get_errors() as $error) {
		    echo "Libxml error: {$error->message}\n";
	    	 }
	}else{
		foreach ($result as $node) {
    			echo "This book includes {$node[unit]} {$node[n]}";
		}
	}

	libxml_use_internal_errors(false);
	
}else{
  echo 'could not load XML document';	
}

?&gt;
</code>
</pre>

<!-- Optional JavaScript -->
    
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>

</body>
</html>
